========基础篇============

1、即便我们每秒都创建了一个描述整个UI树的新元素，React DOM 也只会更新渲染文本节点中发生变化的内容。
每次重新实例化react，依然只是更新变化的内容。例如：
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}
setInterval(tick, 1000);
问题：对比vue看一下，是否也是这个样子的？

2、jsx 语法 必须 导入 react
例如：函数定义的组件，用了jsx语法就需要引入react支持才行。

3、所有的React组件必须像纯函数那样使用它们的props
“纯函数”，它没有改变它自己的输入值，当传入的值相同时，总是会返回相同的结果。

4、类定义的组件有一些特性。例如：拥有局部状态state/生命周期啊！！！
类的方法默认是不会绑定 this 的，所以需要bind手动绑定；（建议在构造函数中绑定或使用属性初始化器语法。）
事件传参：this.deleteRow.bind(this, id)；

5、如果需要存储不用于视觉输出的东西，则可以手动向类中添加其他字段。（除props、state以外）

6、因为 this.props 和 this.state 可能是异步更新的，你不应该依靠它们的值来计算下一个状态。
正确做法：
this.setState((prevState, props) => ({
  counter: prevState.counter + props.increment
}));

7、响应事件 e 是一个合成事件。React 根据 W3C spec 来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。
注意：若函数有传参，e则应该写在参数之后；

8、解构的变量名必须是定义的变量名
例如：import { Component } from 'react';

9、阻止组件渲染（nothing）render 返回 null 即可；

10、受控/非受控组件
其值由React控制的输入表单元素称为“受控组件”
value 属性是只读的， 所以它是 React 中的一个非受控组件

11、ES6当中的计算属性名语法
this.setState({
  [name]: value
});

12、状态提升
几个组件需要共用状态数据的情况下，将这部分共享的状态提升至他们最近的父组件当中进行管理；

13、使用组合而不是继承来复用组件之间的代码。

14、样式的两种形式
<td style={{color: item.stocked ? '' : 'red'}}>name: {item.name}</td>
<td style={item.stocked ? null : {color: 'red'}}>name: {item.name}</td>

15、radio/checkbox的值用 e.target.checked 表示；
<input id="checkbox" type="checkbox" checked={props.searchStock} onChange={changeHandle} />

16、代码优化：循环的时候直接push react元素到数组中，则最后可直接进行渲染；例如：
    list.forEach(item => {
        if (!newObj[item.category]) {
            newObj[item.category] = item.category;
            newList.push(<tr key={item.category}><th>{item.category}</th></tr>);
        }
        newList.push(
            <tr key={item.name}>
                <td>price: {item.price}</td>
                {/* 样式的两种形式 */}
                {/* <td style={{color: item.stocked ? '' : 'red'}}>name: {item.name}</td> */}
                <td style={item.stocked ? null : {color: 'red'}}>name: {item.name}</td>
            </tr>
        );
    });
    return (
        <tbody>
            {newList}
        </tbody>
    )

========高级篇============

1、不能使用表达式来作为 React 元素的标签。例如：
let compnent = {
        1: Comp1
    }
    let type = 1;
    let Middlelayer = compnent[type];
    return (
        <div>
            <h1>通过中间层 引入 变量(compnent[type]) 组件：</h1>
            <Middlelayer />
        </div>
    )

2、 ES6 对象简洁表示法：比如 {foo} 是 {foo: foo} 的简写

3、可以使用 ... 作为扩展操作符来传递整个属性对象
const props = {firstName: 'Ben', lastName: 'Hector'};
  return <Greeting {...props} />;

========问题篇============

1、模块样式如何划分